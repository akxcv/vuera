{"version":3,"file":"index.umd.js","sources":["../../src/config.ts","../../src/wrappers/Vue.tsx","../../src/wrappers/React.tsx","../../src/utils/isReactComponent.ts","../../src/resolvers/Vue.ts","../../src/VuePlugin.ts","../../src/index.tsx","../../src/resolvers/React.tsx"],"sourcesContent":["export function defaultConfig() {\n  return {\n    vueInstanceOptions: {},\n  };\n}\n\nexport default defaultConfig();\n","import React from \"react\";\nimport Vue from \"vue\";\nimport ReactWrapper from \"./React\";\nimport config from \"../config\";\n\nconst VUE_COMPONENT_NAME = \"vuera-internal-component-name\";\n\nconst wrapReactChildren = (createElement: any, children: any) =>\n  createElement(\"vuera-internal-react-wrapper\", {\n    props: {\n      component: () => <div>{children}</div>,\n    },\n  });\n\nexport default class VueContainer extends React.Component {\n  constructor(props: { component: any }) {\n    super(props);\n\n    /**\n     * We have to track the current Vue component so that we can reliably catch updates to the\n     * `component` prop.\n     */\n    (this as any).currentVueComponent = props.component;\n\n    /**\n     * Modify createVueInstance function to pass this binding correctly. Doing this in the\n     * constructor to avoid instantiating functions in render.\n     */\n    const createVueInstance = this.createVueInstance;\n    const self = this;\n    (this as any).createVueInstance = function (\n      element: any,\n      component: any,\n      prevComponent: any\n    ) {\n      createVueInstance(element, self, component, prevComponent);\n    };\n  }\n\n  componentWillReceiveProps(nextProps: any) {\n    const { component, ...props } = nextProps;\n\n    if ((this as any).currentVueComponent !== component) {\n      this.updateVueComponent((this.props as any).component, component);\n    }\n    /**\n     * NOTE: we're not comparing this.props and nextProps here, because I didn't want to write a\n     * function for deep object comparison. I don't know if this hurts performance a lot, maybe\n     * we do need to compare those objects.\n     */\n    Object.assign((this as any).vueInstance.$data, props);\n  }\n\n  componentWillUnmount() {\n    (this as any).vueInstance.$destroy();\n  }\n\n  /**\n   * Creates and mounts the Vue instance.\n   * NOTE: since we need to access the current instance of VueContainer, as well as the Vue instance\n   * inside of the Vue constructor, we cannot bind this function to VueContainer, and we need to\n   * pass VueContainer's binding explicitly.\n   * @param {HTMLElement} targetElement - element to attact the Vue instance to\n   * @param {ReactInstance} reactThisBinding - current instance of VueContainer\n   */\n  createVueInstance(\n    targetElement: any,\n    reactThisBinding: any,\n    _component?: any,\n    _prevComponent?: any\n  ) {\n    const { component, on, ...props } = reactThisBinding.props;\n\n    // `this` refers to Vue instance in the constructor\n    reactThisBinding.vueInstance = new Vue({\n      el: targetElement,\n      data: props,\n      ...config.vueInstanceOptions,\n      render(createElement) {\n        return createElement(\n          VUE_COMPONENT_NAME,\n          {\n            props: this.$data,\n            on,\n          },\n          [wrapReactChildren(createElement, this.children)]\n        );\n      },\n      components: {\n        [VUE_COMPONENT_NAME]: component,\n        \"vuera-internal-react-wrapper\": ReactWrapper,\n      },\n    });\n  }\n\n  updateVueComponent(_prevComponent: any, nextComponent: any) {\n    (this as any).currentVueComponent = nextComponent;\n\n    /**\n     * Replace the component in the Vue instance and update it.\n     */\n    (this as any).vueInstance.$options.components[VUE_COMPONENT_NAME] =\n      nextComponent;\n    (this as any).vueInstance.$forceUpdate();\n  }\n\n  render() {\n    return <div ref={this.createVueInstance as any} />;\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport VueWrapper from \"./Vue\";\n\nconst makeReactContainer = (Component: any) =>\n  class ReactInVue extends React.Component {\n    static displayName = `ReactInVue${\n      Component.displayName || Component.name || \"Component\"\n    }`;\n\n    constructor(props: any) {\n      super(props);\n\n      /**\n       * We create a stateful component in order to attach a ref on it. We will use that ref to\n       * update component's state, which seems better than re-rendering the whole thing with\n       * ReactDOM.\n       */\n      this.state = { ...props };\n    }\n\n    wrapVueChildren(children: any) {\n      // console.log(\"wrapVueChildren: \", children);\n      if (children)\n        return {\n          render: (createElement: any) => createElement(\"div\", children),\n        };\n      return null;\n    }\n\n    render() {\n      const {\n        children,\n        // Vue attaches an event handler, but it is missing an event name, so\n        // it ends up using an empty string. Prevent passing an empty string\n        // named prop to React.\n        \"\": _invoker,\n        ...rest\n      } = (this as any).state;\n      const wrappedChildren = this.wrapVueChildren(children);\n\n      const VueWrapperRender = VueWrapper as unknown as (props: {\n        component: any;\n      }) => JSX.Element;\n\n      if (\"ReactInVueTestAA\" === ReactInVue.displayName) {\n        // console.log(\"THIS IS IT!\", Component.render);\n      }\n\n      // console.log(\"wrappedChildren: \", wrappedChildren);\n\n      return (\n        <Component {...rest}>\n          {wrappedChildren && <VueWrapperRender component={wrappedChildren} />}\n        </Component>\n      );\n    }\n  };\n\nexport default {\n  name: \"ReactInVueRawVueComp\",\n  props: [\"component\", \"passedProps\"],\n  render(createElement: any) {\n    (this as any).createElement = createElement; // save for later\n    return createElement(\"div\", { ref: \"react\" });\n  },\n  methods: {\n    mountReactComponent(comp: any) {\n      const s = this as any;\n      // console.log(\"before creating NewComp\");\n      // console.log(\"Name: \", comp.name || comp.displayName);\n      // console.log(comp);\n\n      const children =\n        s.$slots.default !== undefined ? { children: s.$slots.default } : {};\n\n      let NewComp: React.FC;\n      // if (!comp.functional) {\n        const Component = makeReactContainer(comp);\n        NewComp = (props: any) => (\n          <Component\n            {...props}\n            ref={(ref: any) => (s.reactComponentRef = ref)}\n          />\n        );\n      // } else {\n      //   NewComp = (props: any) => <>{comp.render(s.createElement, props)}</>;\n      // }\n      // NewComp = (props: any) => <>{comp.render(s.createElement, props)}</>;\n\n      ReactDOM.render(\n        <NewComp\n          {...s.$props.passedProps}\n          {...s.$attrs}\n          {...s.$listeners}\n          {...children}\n        />,\n        s.$refs.react\n      );\n      // console.log(\"after creating NewComp\");\n    },\n  },\n  mounted() {\n    (this as any).mountReactComponent((this as any).$props.component);\n  },\n  beforeDestroy() {\n    ReactDOM.unmountComponentAtNode((this as any).$refs.react);\n  },\n  updated() {\n    /**\n     * AFAIK, this is the only way to update children. It doesn't seem to be possible to watch\n     * `$slots` or `$children`.\n     */\n    if ((this as any).$slots.default !== undefined) {\n      (this as any).reactComponentRef.setState({\n        children: (this as any).$slots.default,\n      });\n    } else {\n      (this as any).reactComponentRef.setState({ children: null });\n    }\n  },\n  inheritAttrs: false,\n  watch: {\n    $attrs: {\n      handler() {\n        (this as any).reactComponentRef.setState({ ...(this as any).$attrs });\n      },\n      deep: true,\n    },\n    \"$props.component\": {\n      handler(newValue: any) {\n        (this as any).mountReactComponent(newValue);\n      },\n    },\n    $listeners: {\n      handler() {\n        (this as any).reactComponentRef.setState({\n          ...(this as any).$listeners,\n        });\n      },\n      deep: true,\n    },\n    \"$props.passedProps\": {\n      handler() {\n        (this as any).reactComponentRef.setState({\n          ...(this as any).$props.passedProps,\n        });\n      },\n      deep: true,\n    },\n  },\n};\n","import Vue from \"vue\";\n\nexport default function isReactComponent(component: any) {\n  if (typeof component === \"object\" && !isReactForwardReference(component)) {\n    return false;\n  }\n\n  return !(\n    typeof component === \"function\" &&\n    component.prototype &&\n    ((component.prototype.constructor.super &&\n      component.prototype.constructor.super.isVue) ||\n      component.prototype instanceof Vue)\n  );\n}\n\nfunction isReactForwardReference(component: any) {\n  return (\n    component.$$typeof &&\n    component.$$typeof.toString() === \"Symbol(react.forward_ref)\"\n  );\n}\n","import { AsyncComponent, Component, CreateElement } from \"vue\";\nimport ReactWrapper from \"../wrappers/React\";\n\nexport default function VueResolver<T>(component: (props: T) => any) {\n  return {\n    components: { ReactWrapper },\n    props: [\"passedProps\"],\n    inheritAttrs: false,\n    render(createElement: CreateElement) {\n      return createElement(\n        \"react-wrapper\",\n        {\n          props: {\n            component,\n            passedProps: (this as any).$props.passedProps,\n          },\n          attrs: (this as any).$attrs,\n          on: (this as any).$listeners,\n        },\n        (this as any).$slots.default\n      );\n    },\n  } as unknown as\n    | Component<any, any, any, T>\n    | AsyncComponent<any, any, any, T>;\n}\n","import _Vue, { Component } from \"vue\";\n\nimport isReactComponent from \"./utils/isReactComponent\";\nimport VueResolver from \"./resolvers/Vue\";\n\n/**\n * This mixin automatically wraps all React components into Vue.\n */\nexport default {\n  install(Vue: typeof _Vue, options: any) {\n    console.log(\"Installing Vuera VuePlugin\");\n    /**\n     * We define a custom merging strategy for the `components` field. This strategy really just\n     * wraps all the React components while leaving Vue components as is.\n     */\n    const originalComponentsMergeStrategy =\n      Vue.config.optionMergeStrategies.components;\n\n    Vue.config.optionMergeStrategies.components = function (\n      parent: { [k: string]: Component },\n      ...args: any\n    ) {\n      const mergedValue = originalComponentsMergeStrategy(parent, ...args);\n\n      const wrappedComponents = mergedValue\n        ? Object.entries(mergedValue).reduce(\n            (acc, [k, v]) => ({\n              ...acc,\n              [k]: isReactComponent(v) ? VueResolver(v as any) : v,\n            }),\n            {}\n          )\n        : mergedValue;\n      return Object.assign(mergedValue, wrappedComponents) as {\n        [k: string]: Component;\n      };\n    };\n    Vue.prototype.constructor.isVue = true;\n  },\n};\n","import ReactWrapper from \"./wrappers/React\";\nimport VueWrapper from \"./wrappers/Vue\";\nimport VuePlugin from \"./VuePlugin\";\nimport VueInReact, {\n  babelReactResolver as __vueraReactResolver,\n} from \"./resolvers/React\";\nimport config from \"./config\";\nimport ReactInVue from \"./resolvers/Vue\";\n\nconst SayHello = ({ name }: { name: string }): JSX.Element => (\n  <div>Hey {name}, say hello to TypeScript.</div>\n);\n\nexport {\n  ReactWrapper,\n  VueWrapper,\n  __vueraReactResolver,\n  VuePlugin,\n  VueInReact,\n  ReactInVue,\n  config,\n  // TEST\n  SayHello,\n};\n","/* eslint-disable prefer-object-spread/prefer-object-spread */\nimport React from \"react\";\nimport VueWrapper from \"../wrappers/Vue\";\nimport isReactComponent from \"../utils/isReactComponent\";\n\nexport default function ReactResolver(component: any) {\n  return isReactComponent(component)\n    ? component\n    : (props: any) => <VueWrapper {...props} component={component} />;\n}\n\n/**\n * This function gets imported by the babel plugin. It wraps a suspected React element and, if it\n * isn't a valid React element, wraps it into a Vue container.\n */\nexport function babelReactResolver(component: any, props: any, children: any) {\n  return isReactComponent(component)\n    ? React.createElement(component, props, children)\n    : React.createElement(\n        VueWrapper,\n        Object.assign({ component }, props),\n        children\n      );\n}\n"],"names":["vueInstanceOptions","VUE_COMPONENT_NAME","wrapReactChildren","createElement","children","props","component","_jsx","VueContainer","_this","currentVueComponent","createVueInstance","self","element","prevComponent","componentWillReceiveProps","nextProps","this","updateVueComponent","Object","assign","vueInstance","$data","componentWillUnmount","$destroy","targetElement","reactThisBinding","_component","_prevComponent","on","Vue","el","data","config","render","components","ReactWrapper","nextComponent","$options","$forceUpdate","ref","React","Component","name","methods","mountReactComponent","comp","NewComp","s","undefined","$slots","state","wrapVueChildren","rest","wrappedChildren","VueWrapper","displayName","makeReactContainer","reactComponentRef","ReactDOM","$props","passedProps","$attrs","$listeners","$refs","react","mounted","beforeDestroy","unmountComponentAtNode","updated","setState","inheritAttrs","watch","handler","deep","newValue","isReactComponent","$$typeof","toString","isReactForwardReference","prototype","constructor","isVue","VueResolver","attrs","install","options","console","log","originalComponentsMergeStrategy","optionMergeStrategies","parent","mergedValue","wrappedComponents","entries","reduce","acc","v","_jsxs"],"mappings":"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"}