{"version":3,"file":"index.modern.js","sources":["../../src/config.ts","../../src/wrappers/Vue.tsx","../../src/wrappers/React.tsx","../../src/utils/isReactComponent.ts","../../src/resolvers/Vue.ts","../../src/VuePlugin.ts","../../src/resolvers/React.tsx","../../src/index.tsx"],"sourcesContent":["export function defaultConfig() {\n  return {\n    vueInstanceOptions: {},\n  };\n}\n\nexport default defaultConfig();\n","import React from \"react\";\nimport Vue from \"vue\";\nimport ReactWrapper from \"./React\";\nimport config from \"../config\";\n\nconst VUE_COMPONENT_NAME = \"vuera-internal-component-name\";\n\nconst wrapReactChildren = (createElement: any, children: any) =>\n  createElement(\"vuera-internal-react-wrapper\", {\n    props: {\n      component: () => <div>{children}</div>,\n    },\n  });\n\nexport default class VueContainer extends React.Component {\n  constructor(props: { component: any }) {\n    super(props);\n\n    /**\n     * We have to track the current Vue component so that we can reliably catch updates to the\n     * `component` prop.\n     */\n    (this as any).currentVueComponent = props.component;\n\n    /**\n     * Modify createVueInstance function to pass this binding correctly. Doing this in the\n     * constructor to avoid instantiating functions in render.\n     */\n    const createVueInstance = this.createVueInstance;\n    const self = this;\n    (this as any).createVueInstance = function (\n      element: any,\n      component: any,\n      prevComponent: any\n    ) {\n      createVueInstance(element, self, component, prevComponent);\n    };\n  }\n\n  componentWillReceiveProps(nextProps: any) {\n    const { component, ...props } = nextProps;\n\n    if ((this as any).currentVueComponent !== component) {\n      this.updateVueComponent((this.props as any).component, component);\n    }\n    /**\n     * NOTE: we're not comparing this.props and nextProps here, because I didn't want to write a\n     * function for deep object comparison. I don't know if this hurts performance a lot, maybe\n     * we do need to compare those objects.\n     */\n    Object.assign((this as any).vueInstance.$data, props);\n  }\n\n  componentWillUnmount() {\n    (this as any).vueInstance.$destroy();\n  }\n\n  /**\n   * Creates and mounts the Vue instance.\n   * NOTE: since we need to access the current instance of VueContainer, as well as the Vue instance\n   * inside of the Vue constructor, we cannot bind this function to VueContainer, and we need to\n   * pass VueContainer's binding explicitly.\n   * @param {HTMLElement} targetElement - element to attact the Vue instance to\n   * @param {ReactInstance} reactThisBinding - current instance of VueContainer\n   */\n  createVueInstance(\n    targetElement: any,\n    reactThisBinding: any,\n    _component?: any,\n    _prevComponent?: any\n  ) {\n    const { component, on, ...props } = reactThisBinding.props;\n\n    // `this` refers to Vue instance in the constructor\n    reactThisBinding.vueInstance = new Vue({\n      el: targetElement,\n      data: props,\n      ...config.vueInstanceOptions,\n      render(createElement) {\n        return createElement(\n          VUE_COMPONENT_NAME,\n          {\n            props: this.$data,\n            on,\n          },\n          [wrapReactChildren(createElement, this.children)]\n        );\n      },\n      components: {\n        [VUE_COMPONENT_NAME]: component,\n        \"vuera-internal-react-wrapper\": ReactWrapper,\n      },\n    });\n  }\n\n  updateVueComponent(_prevComponent: any, nextComponent: any) {\n    (this as any).currentVueComponent = nextComponent;\n\n    /**\n     * Replace the component in the Vue instance and update it.\n     */\n    (this as any).vueInstance.$options.components[VUE_COMPONENT_NAME] =\n      nextComponent;\n    (this as any).vueInstance.$forceUpdate();\n  }\n\n  render() {\n    return <div ref={this.createVueInstance as any} />;\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport VueWrapper from \"./Vue\";\n\nconst makeReactContainer = (Component: any) =>\n  class ReactInVue extends React.Component {\n    static displayName = `ReactInVue${\n      Component.displayName || Component.name || \"Component\"\n    }`;\n\n    constructor(props: any) {\n      super(props);\n\n      /**\n       * We create a stateful component in order to attach a ref on it. We will use that ref to\n       * update component's state, which seems better than re-rendering the whole thing with\n       * ReactDOM.\n       */\n      this.state = { ...props };\n    }\n\n    wrapVueChildren(children: any) {\n      // console.log(\"wrapVueChildren: \", children);\n      if (children)\n        return {\n          render: (createElement: any) => createElement(\"div\", children),\n        };\n      return null;\n    }\n\n    render() {\n      const {\n        children,\n        // Vue attaches an event handler, but it is missing an event name, so\n        // it ends up using an empty string. Prevent passing an empty string\n        // named prop to React.\n        \"\": _invoker,\n        ...rest\n      } = (this as any).state;\n      const wrappedChildren = this.wrapVueChildren(children);\n\n      const VueWrapperRender = VueWrapper as unknown as (props: {\n        component: any;\n      }) => JSX.Element;\n\n      if (\"ReactInVueTestAA\" === ReactInVue.displayName) {\n        // console.log(\"THIS IS IT!\", Component.render);\n      }\n\n      // console.log(\"wrappedChildren: \", wrappedChildren);\n\n      return (\n        <Component {...rest}>\n          {wrappedChildren && <VueWrapperRender component={wrappedChildren} />}\n        </Component>\n      );\n    }\n  };\n\nexport default {\n  name: \"ReactInVueRawVueComp\",\n  props: [\"component\", \"passedProps\"],\n  render(createElement: any) {\n    (this as any).createElement = createElement; // save for later\n    return createElement(\"div\", { ref: \"react\" });\n  },\n  methods: {\n    mountReactComponent(comp: any) {\n      const s = this as any;\n      // console.log(\"before creating NewComp\");\n      // console.log(\"Name: \", comp.name || comp.displayName);\n      // console.log(comp);\n\n      const children =\n        s.$slots.default !== undefined ? { children: s.$slots.default } : {};\n\n      let NewComp: React.FC;\n      // if (!comp.functional) {\n        const Component = makeReactContainer(comp);\n        NewComp = (props: any) => (\n          <Component\n            {...props}\n            ref={(ref: any) => (s.reactComponentRef = ref)}\n          />\n        );\n      // } else {\n      //   NewComp = (props: any) => <>{comp.render(s.createElement, props)}</>;\n      // }\n      // NewComp = (props: any) => <>{comp.render(s.createElement, props)}</>;\n\n      ReactDOM.render(\n        <NewComp\n          {...s.$props.passedProps}\n          {...s.$attrs}\n          {...s.$listeners}\n          {...children}\n        />,\n        s.$refs.react\n      );\n      // console.log(\"after creating NewComp\");\n    },\n  },\n  mounted() {\n    (this as any).mountReactComponent((this as any).$props.component);\n  },\n  beforeDestroy() {\n    ReactDOM.unmountComponentAtNode((this as any).$refs.react);\n  },\n  updated() {\n    /**\n     * AFAIK, this is the only way to update children. It doesn't seem to be possible to watch\n     * `$slots` or `$children`.\n     */\n    if ((this as any).$slots.default !== undefined) {\n      (this as any).reactComponentRef.setState({\n        children: (this as any).$slots.default,\n      });\n    } else {\n      (this as any).reactComponentRef.setState({ children: null });\n    }\n  },\n  inheritAttrs: false,\n  watch: {\n    $attrs: {\n      handler() {\n        (this as any).reactComponentRef.setState({ ...(this as any).$attrs });\n      },\n      deep: true,\n    },\n    \"$props.component\": {\n      handler(newValue: any) {\n        (this as any).mountReactComponent(newValue);\n      },\n    },\n    $listeners: {\n      handler() {\n        (this as any).reactComponentRef.setState({\n          ...(this as any).$listeners,\n        });\n      },\n      deep: true,\n    },\n    \"$props.passedProps\": {\n      handler() {\n        (this as any).reactComponentRef.setState({\n          ...(this as any).$props.passedProps,\n        });\n      },\n      deep: true,\n    },\n  },\n};\n","import Vue from \"vue\";\n\nexport default function isReactComponent(component: any) {\n  if (typeof component === \"object\" && !isReactForwardReference(component)) {\n    return false;\n  }\n\n  return !(\n    typeof component === \"function\" &&\n    component.prototype &&\n    ((component.prototype.constructor.super &&\n      component.prototype.constructor.super.isVue) ||\n      component.prototype instanceof Vue)\n  );\n}\n\nfunction isReactForwardReference(component: any) {\n  return (\n    component.$$typeof &&\n    component.$$typeof.toString() === \"Symbol(react.forward_ref)\"\n  );\n}\n","import { AsyncComponent, Component, CreateElement } from \"vue\";\nimport ReactWrapper from \"../wrappers/React\";\n\nexport default function VueResolver<T>(component: (props: T) => any) {\n  return {\n    components: { ReactWrapper },\n    props: [\"passedProps\"],\n    inheritAttrs: false,\n    render(createElement: CreateElement) {\n      return createElement(\n        \"react-wrapper\",\n        {\n          props: {\n            component,\n            passedProps: (this as any).$props.passedProps,\n          },\n          attrs: (this as any).$attrs,\n          on: (this as any).$listeners,\n        },\n        (this as any).$slots.default\n      );\n    },\n  } as unknown as\n    | Component<any, any, any, T>\n    | AsyncComponent<any, any, any, T>;\n}\n","import _Vue, { Component } from \"vue\";\n\nimport isReactComponent from \"./utils/isReactComponent\";\nimport VueResolver from \"./resolvers/Vue\";\n\n/**\n * This mixin automatically wraps all React components into Vue.\n */\nexport default {\n  install(Vue: typeof _Vue, options: any) {\n    console.log(\"Installing Vuera VuePlugin\");\n    /**\n     * We define a custom merging strategy for the `components` field. This strategy really just\n     * wraps all the React components while leaving Vue components as is.\n     */\n    const originalComponentsMergeStrategy =\n      Vue.config.optionMergeStrategies.components;\n\n    Vue.config.optionMergeStrategies.components = function (\n      parent: { [k: string]: Component },\n      ...args: any\n    ) {\n      const mergedValue = originalComponentsMergeStrategy(parent, ...args);\n\n      const wrappedComponents = mergedValue\n        ? Object.entries(mergedValue).reduce(\n            (acc, [k, v]) => ({\n              ...acc,\n              [k]: isReactComponent(v) ? VueResolver(v as any) : v,\n            }),\n            {}\n          )\n        : mergedValue;\n      return Object.assign(mergedValue, wrappedComponents) as {\n        [k: string]: Component;\n      };\n    };\n    Object.getPrototypeOf(Vue).constructor.isVue = true;\n  },\n};\n","/* eslint-disable prefer-object-spread/prefer-object-spread */\nimport React from \"react\";\nimport VueWrapper from \"../wrappers/Vue\";\nimport isReactComponent from \"../utils/isReactComponent\";\n\nexport default function ReactResolver(component: any) {\n  return isReactComponent(component)\n    ? component\n    : (props: any) => <VueWrapper {...props} component={component} />;\n}\n\n/**\n * This function gets imported by the babel plugin. It wraps a suspected React element and, if it\n * isn't a valid React element, wraps it into a Vue container.\n */\nexport function babelReactResolver(component: any, props: any, children: any) {\n  return isReactComponent(component)\n    ? React.createElement(component, props, children)\n    : React.createElement(\n        VueWrapper,\n        Object.assign({ component }, props),\n        children\n      );\n}\n","import ReactWrapper from \"./wrappers/React\";\nimport VueWrapper from \"./wrappers/Vue\";\nimport VuePlugin from \"./VuePlugin\";\nimport VueInReact, {\n  babelReactResolver as __vueraReactResolver,\n} from \"./resolvers/React\";\nimport config from \"./config\";\nimport ReactInVue from \"./resolvers/Vue\";\n\nconst SayHello = ({ name }: { name: string }): JSX.Element => (\n  <div>Hey {name}, say hello to TypeScript.</div>\n);\n\nexport {\n  ReactWrapper,\n  VueWrapper,\n  __vueraReactResolver,\n  VuePlugin,\n  VueInReact,\n  ReactInVue,\n  config,\n  // TEST\n  SayHello,\n};\n"],"names":["vueInstanceOptions","wrapReactChildren","createElement","children","props","component","_jsx","VueContainer","React","Component","constructor","super","this","currentVueComponent","createVueInstance","self","element","prevComponent","componentWillReceiveProps","nextProps","updateVueComponent","Object","assign","vueInstance","$data","componentWillUnmount","$destroy","targetElement","reactThisBinding","_component","_prevComponent","on","Vue","el","data","config","render","components","ReactWrapper","nextComponent","$options","$forceUpdate","ref","makeReactContainer","state","wrapVueChildren","rest","wrappedChildren","VueWrapper","displayName","name","methods","mountReactComponent","comp","s","undefined","$slots","default","NewComp","reactComponentRef","ReactDOM","$props","passedProps","$attrs","$listeners","$refs","react","mounted","beforeDestroy","unmountComponentAtNode","updated","setState","inheritAttrs","watch","handler","deep","newValue","isReactComponent","$$typeof","toString","isReactForwardReference","prototype","isVue","VueResolver","attrs","install","options","console","log","originalComponentsMergeStrategy","optionMergeStrategies","parent","args","mergedValue","wrappedComponents","entries","reduce","acc","k","v","getPrototypeOf","ReactResolver","babelReactResolver","SayHello","_jsxs"],"mappings":"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"}